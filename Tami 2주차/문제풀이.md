### A 1021 - 회전하는 큐

큐의 push(), pop(), front() 함수를 이용해 3가지 연산을 구현할 수 있을 것 같아 
큐를 이용하기로 결정 

**풀이과정**
- N개의 원소를 큐에 넣음 
- 1번 연산을 하기 위해서는 무조건 해당 원소를 맨 앞으로 이동시켜야 함
- 원소를 맨 앞으로 위치시키는 데는 두가지 방법이 있다.
- 첫번째 방법은 원소를 왼쪽으로 한칸씩 이동시키는 것(2번 연산)이고
- 두번째 방법은 원소를 오른쪽으로 한칸씩 이동시키는 것(3번 연산)이다
- 첫번째 방법과 두번째 방법에 필요한 연산의 횟수를 비교해 더 작은 값을 반환

**시간 복잡도**
- O(M*N) -> N번의 연산 * M개의 원소 

-------
### B 1158 - 요세푸스 문제
큐를 이용해 구현 -> 원순열, 반복되는 구조 

**풀이과정**
- 1부터 N까지의 정수를 큐에 넣는다
- 1부터 K까지 for문을 도는데, K보다 작을 때는 원소를 pop()해서 다시 맨 뒤에 push()한다
- K일 때는 맨 앞에 있는 원소를 출력하고 pop()한다.
- 큐가 빌 때 까지 위의 과정을 반복한다 

**시간 복잡도**
- O(N*K)
------
### C 2346 - 풍선 터뜨리기 
큐를 이용해 구현 -> 원순열, 반복되는 구조

**풀이과정**
- 1부터 N까지의 정수를 큐에 넣는다
- 각 풍선에 들어있는 종이에 적힌 숫자를 담기 위한 배열 하나를 선언한다
- 첫번째 풍선을 터뜨린다 -> pop(), 출력
- 첫번째 풍선에 들어있는 숫자를 K라 할 때, 
  - K가 양수인 경우 반복문을 K-1 번 돌며 맨 앞의 원소를 큐에서 빼내어 맨 뒤에 삽입한다
  - K가 음수인 경우 반복문을 (현재 큐의 사이즈) + K -1 번 돌며 맨 앞의 원소를 큐에서 빼내어 맨 뒤에 삽입한다
- 맨 앞의 원소를 pop()하고 출력한 후, 해당 풍선에 들어있는 숫자를 K로 하여 큐가 빌 때까지 위의 과정 반복

**시간 복잡도**
- O(N*K)
-------

### D 1406 - 에디터
스택 두개를 이용해 구현 - > 커서를 기준으로 두개의 스택에 문자열 저장 

**풀이과정**
- 스택 두개를 선언한다. 편의상 커서를 기준으로 왼쪽에 있는 문자열을 담을 스택을 left, 오른족에 있는 문자열을 담을 스택을 right라고 하자; 
- 첫째줄에 있는 문자열을 left에 담는다 
- L이 입력될 경우: left가 비어있지 않을 경우, left에서 원소 하나를 pop()해서 right에 삽입 
- D가 입력될 경우: right가 비어있지 않을 경우, right에서 원소 하나를 pop()해서 left에 삽입
- B가 입력될 경우: left가 비어있지 않을 경우, left에서 원소 하나를 pop()
- P$가 입력될 경우: left에 $를 삽입함
- 모든 입력을 수행한 후, left의 모든 원소를 right로 옮기고 right의 모든 원소 출력

**시간 복잡도**

O(N)

---------

### E - 후위표기식  
----------
### F 1874 - 스택수열
스택을 이용해 풀이

**풀이과정**
- 1부터 N까지의 정수를 다룰 스택 s와 수열을 저장할 배열 arr, push 해야할 숫자를 저장할 변수 e를 정의
- 수열의 마지막 값에 도달할 때까지 반복문 돌기
  - 스택 s의 top()과 현재 비교해야 하는 수열 원소의 값이 동일하면 s에서 pop(), 수열의 인덱스 +1 
  - 동일하지 않을 경우
    - e의 값이 현재 비교해야 하는 수열 원소의 값보다 작으면 s에 push()
    - 그렇지 않으면 NO출력 

**시간 복잡도**

O(N)

-----

### G 1764 - 듣보잡
set을 이용해 풀이 

**풀이과정**
- 듣도 못한 사람들을 set A에 저장하고, 보도 못한 사람들을 set B에 저장, 듣도 보도 못한 사람들을 set C에 저장한다.
- 먼저 set A에 들어갈 원소를 넣어주고, set B에 원소를 넣는 과정에서  set A에 포함된 원소일 경우 set C에도 넣어준다
- set C의 원소들을 사전순으로 출력해줌 

**시간 복잡도**

O(logn) -> set이 트리구조로 되어있기 때문에

-----

### H 10799 - 쇠막대기

**풀이과정**
- 현 시점에 있는 막대의 수를 t, 전체 막대의 수를 sum이라고 하자
- 괄호의 종류에 따라 분기문 처리
  - '(' 일 때 : t + 1
  - '()' 일 때: sum = sum + t
  - ')' 일 때: sum = sum + 1
- 마지막에 sum 반환 

**시간 복잡도**
O(N)

--------
### I 17298 - 오큰수 
스택 사용, 이중 반복문을 돌게 되면 시간 초과 에러

**풀이과정**
- 수열을 저장할 배열 arr, 오큰수를 저장할 배열 r과 수열 arr의 인덱스를 저장하기 위한 스택 s를 정의
-  arr의 첫번째 인덱스 0을 s에 push
- 반복문을 돌면서, 스택의 top()에 해당하는 수가 i라고 할때, arr[i] 가 수열의 원소보다 더 작으면 pop()하고 r[i]에 해당 수열의 원소를 넣어준다. 스택에는 해당 원소를 Push해준다.
- 수열 arr의 모든 원소를 탐색했는데도 수열에 남아있는 수가 있으면 그 수에 해당하는 arr의 값에는 -1을 넣어준다
-  반복문을 돈 후에는 배열 r에 있는 원소들을 출력해준다.
- 

**시간 복잡도**

O(nlogn)

----------

### J 2304 - 창고 다각형


**풀이과정**
- 맨 앞에 있는 막대와 맨 뒤에 있는 막대, 가장 높이가 긴 막대를 찾는다
- 가장 높이가 긴 막대를 기준으로 왼쪽에 있는 막대들은 맨 앞에서부터 탐색하며 높이의 최댓값을 업데이트함 
- 오른쪽에 있는 막대들은 맨 뒤에서부터 탐색하며 높이의 최댓값을 업데이트 함

**시간 복잡도**

O(n)

----------
### K 2841 - 외계인의 기타 연주 
우선순위 큐로 구현 

**풀이과정**
- 전체 줄의 갯수만큼 우선순위큐를 만든다. 각 큐에는 줄 별로 프렛을 저장한다. 각 큐에서는 프렛이 높은 음이 먼저 pop()될 수 있도록 한다.
- 큐의 top()이 현재 음의 프렛보다 낮거나 같을 때가지 pop()하고 count를 1 증가시킨다. 
- 큐의 top()이 현재 음의 프렛과 같을 경우 해당 음의 프렛을 push()
- 큐의 top()이 현재 음의 프렛보다 낮을 경우 해당 음의 프렛을 Push()하고 count를 1 증가시킨다.

**시간 복잡도**

nlog(n)

--------

### L 3986 - 좋은 단어
스택 이용

**풀이방법**
- 스택에 단어의 한글자씩을 넣고 스택의 top()이 현재 넣으려는 글자와 같을 때 pop, 다르면 현재의 글자를 Push
- 모든 단어에 대해 위의 과정을 반복하고 난 후에 스택이 비어있지 않으면 좋은 글자가 아님

**시간 복잡도**
nlog(n)

---------
### M 1966 - 프린터큐

우선 순위 큐와 큐를 이용해 풀이

**풀이방법**
  - 각 문서의 인덱스(순서)와 중요도를 쌍으로 하는 pair를 원소로 가지는 큐를 생성한다.
  - 문서 큐의 중요도를 우선순위로 하는 우선순위 큐를 생성한다.
  - 반복문을 돌며 우선순위큐의 top()과 큐의 front()를 비교하고, top()과 front()가 같을 경우 큐와 우선순위큐에서 모두 pop()
  - 문제에서 요구하는 인덱스가 pop() 될 때까지 위의 과정을 반복




### N 2075 - N번째 큰 수 

**우선순위큐를 이용해 풀이**

**풀이방법**
- 메모리 제한이 있기 때문에 크기를 n으로 유지하는 우선순위 최소힙 큐를 만들어서 풀이 
  




### O 2696 - 중앙값 구하기 

**풀이방법**
- 각 수열의 원소를 읽을 때마다 중앙값을 계산.
- 홀수 번째 일때 출력

**시간 복잡도**

O(N^2)

-----------

### p 1715 - 카드 정렬하기 

우선순위 큐를 이용해 구현


**풀이과정**
- 묶음의 갯수가 하나가 될 때까지 매번 작은 수 두개를 골라야 함
- 두 묶음을 합쳐 새로운 묶음이 생기면, 그 묶음도 우선순위 큐에 넣어야함 
- 큐에서 가장 작은 수부터 반환을 하도록 함

시간 복잡도 
O(logN) -> 우선순위큐는 트리구조 

-------

### Q 1918 - 후위 표기식 

스택을 이용해 구현 

**풀이과정**
- '(' 일 때: push
- ')' 일 때: '(' 나올 때까지 push
- '+' or '-' 일 때: 스택에 있는 모든 연산자 pop, 그 후 자기자신 push
- '*' of '/' 일 때: 스택에 있는 * / 연산자 pop, 그 후 자기자신 Push 
- 피연산자는 무조건 출력 

**시간 복잡도**

O(nlog(n))

